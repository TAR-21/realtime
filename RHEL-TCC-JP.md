## RHEL上でIntel TCCを有効化し、Podmanコンテナでリアルタイム性能を検証する手順書

このドキュメントは、Intel TCC対応CPUを搭載したマシン上でRHEL for Real Timeをセットアップし、Podmanコンテナ内のアプリケーションでそのリアルタイム性能を実証するための一連の手順をまとめたものです。

-----

### Part 1: ホストOSのリアルタイム環境構築

**目的**: OSとハードウェアをチューニングし、特定のCPUコアをリアルタイムタスク専用の「聖域」として確保する。

#### **Step 1. BIOS/UEFIの設定 (ハードウェアレベルの準備)**

**目的**: OSが起動する前に、CPU自体をリアルタイム処理に最適化された「本気モード」に切り替えること。

PCのCPUは通常、性能と消費電力のバランスを取るように設計されています。例えば、PCがアイドル状態のときは自動的にスリープモード（C-state）に入って電力を節約したり、必要に応じて動的にクロック周波数（P-state / Turbo Boost）を変動させたりします。

しかし、これらの省電力機能や動的な性能調整は、リアルタイム処理にとっては「予測できない遅延（ジッター）」の原因となります。スリープから復帰する時間や、クロック周波数が安定するまでの時間は、ナノ秒単位の精度を求める上では無視できないノイズです。

「Intel® TCC Mode」を有効にするというのは、これらの変動要因をハードウェアレベルで排除または最適化する操作です。

**具体的な手順**:

1.  **BIOS/UEFIへのアクセス**: PCの電源投入直後、メーカーのロゴが表示されている間に特定のキー（多くは `F2`、`Del`、`F10`、`Esc`など）を押して設定画面に入ります。
2.  **設定項目の探索**: BIOSのメニューはメーカーやモデルによって大きく異なりますが、一般的に以下の様な場所に設定項目があります。
      * `Advanced` -\> `CPU Configuration`
      * `Performance` / `Overclocking`
      * `Platform Settings`
3.  **有効化と保存**: 「Intel TCC Mode」や、それに類する「Real-Time Mode」などの項目を\*\*Enabled (有効)\*\*に変更し、設定を保存して（多くは`F10`キー）再起動します。

このステップを完了することで初めて、CPUはOSが出すリアルタイムの要求に、常に一定の応答時間で応えられる準備が整います。

#### **Step 2. OSの準備 (OSレベルの準備)**

**目的**: リアルタイムタスクを最優先で処理できるように設計された、特殊なOSカーネルを導入すること。

私たちが普段使う標準的なOSカーネル（Windows, macOS, 通常のLinux）は、「公平性」を重視して作られています。Webブラウザ、音楽プレーヤー、バックグラウンドのウイルススキャンなど、様々なタスクにCPU時間を公平に分け与え、全てのアプリケーションがスムーズに動いているように見せるのが得意です。

しかし、この「公平性」は、絶対に遅れてはならないタスクがあるリアルタイムシステムでは問題になります。

「RHEL for Real Time」をインストールするというのは、この「公平な」スケジューラを持つ標準カーネルを、「優先度こそが全て」という哲学で作られた**リアルタイムカーネル (`kernel-rt`)** に置き換える作業です。

**リアルタイムカーネルの主な特徴**:

  * **完全プリエンプション (Fully Preemptible)**: 標準カーネルでは中断できない処理の途中であっても、より優先度の高いタスクが来た場合は、即座に処理を中断して最優先タスクにCPUを明け渡します。これにより、タスクの待ち時間が劇的に短縮されます。
  * **優先度ベースのスケジューリング**: 「公平さ」よりも、タスクに設定された優先度番号を絶対的な基準として処理の順番を決定します。

**具体的な手順**:
RHEL for Real Timeは、完全に別のOSというよりは、RHELにリアルタイム機能を追加するアドオンパッケージ群です。

1.  **リポジトリの有効化**: まず、`dnf`（パッケージ管理ツール）に対して、リアルタイム関連のパッケージがどこにあるかを教える必要があります。
    ```bash
    sudo subscription-manager repos --enable rhel-9-for-x86_64-rt-rpms
    ```
2.  **パッケージグループのインストール**: 次に、リアルタイムカーネル本体や関連ツール一式をインストールします。
    ```bash
    sudo dnf groupinstall "RT"
    ```
3.  **再起動と確認**: インストール後に再起動し、新しいリアルタイムカーネルで起動していることを確認します。
    ```bash
    uname -r
    ```
    出力されるバージョン文字列の末尾に **`-rt`** が付いていれば成功です。

このステップにより、OSレベルでリアルタイムタスクを最優先に処理する基盤が整います。

#### **Step 3. カーネルのチューニング (CPUコアの隔離)**

  - `grubby`コマンドを使い、リアルタイムタスク専用のCPUコアをOSの汎用スケジューラから隔離する。
  - **実行例（コア2, 3を隔離）**:
    ```bash
    sudo grubby --update-kernel=ALL --args="isolcpus=2-3 nohz_full=2-3 rcu_nocbs=2-3"
    ```
  - **反映と確認**:
    システムを再起動後、`cat /proc/cmdline`を実行し、上記パラメータが含まれていることを確認する。

#### **Step 4. `tuned`プロファイルの適用**

  - OS全体の動作モードをリアルタイム向けに最適化する。
  - **実行コマンド**:
    ```bash
    sudo tuned-adm profile realtime
    ```
  - **確認**:
    `tuned-adm active`を実行し、`Current active profile: realtime`と表示されることを確認する。

-----

### Part 2: リアルタイム検証用コンテナの作成

**目的**: リアルタイム性能を測定する標準ツール`cyclictest`を、ソースコードからビルドしてコンテナイメージに含める。

#### **Step 1. `Containerfile`の作成**

  - 以下の内容で`Containerfile`を作成する。これにより、サブスクリプションに依存せずに`rt-tests`ツールを導入できる。
    ```dockerfile
    # ベースイメージとしてUBI 9を指定
    FROM registry.redhat.io/ubi9/ubi:latest

    # STEP 1: rt-testsのビルドに必要なツールとライブラリをインストール
    RUN dnf install -y \
        git \
        make \
        gcc \
        procps-ng \
        numactl-devel \
        libcap-devel \
        && dnf clean all

    # STEP 2: rt-testsのソースコードをダウンロードし、ビルドしてインストール
    RUN git clone https://git.kernel.org/pub/scm/utils/rt-tests/rt-tests.git && \
        cd rt-tests && \
        make all && \
        make install

    # デフォルトのコマンドを設定
    CMD ["cyclictest", "--help"]
    ```

#### **Step 2. Podmanイメージのビルド**

  - 上記`Containerfile`を元に、`rt-test-app`という名前のコンテナイメージを作成する。
    ```bash
    sudo podman build -t rt-test-app .
    ```

-----

### Part 3: リアルタイム性能の測定と検証

**目的**: OSに高負荷をかけながら、隔離したCPUコア上で動作するリアルタイムタスクの性能が劣化しないことを証明する。

#### **Step 1. 負荷ツールのインストール（ホストOS側）**

  - 負荷生成ツール`stress-ng`をホストOSにインストールする。
    ```bash
    sudo dnf install -y epel-release
    sudo dnf install -y stress-ng
    ```

#### **Step 2. 性能測定の実行（ターミナル2つ使用）**

  - **ターミナル① - `cyclictest`の起動**:
    隔離したCPUコア（2,3）上で、リアルタイム権限を与えて`cyclictest`を起動する。

    ```bash
    podman run --rm --cap-add=SYS_NICE --cpuset-cpus="2,3" --ulimit memlock=-1:-1 rt-test-app chrt -f 80 cyclictest -t1 -p 80 -i 1000 -m
    ```

  - **ターミナル② - `stress-ng`による負荷印加**:
    `cyclictest`が動いていない\*\*隔離されていないCPUコア（例: 0,1）\*\*に対して高負荷をかける。

    ```bash
    taskset -c 0,1 stress-ng --cpu 2 --vm 2 --timeout 120s
    ```

#### **Step 3. 結果の評価**

  - `stress-ng`が動作している間、ターミナル①の`cyclictest`の`Max`（最大遅延時間）の値を確認する。
  - **成功の基準**: ホストOSに高い負荷がかかっていても、`Max`の値が**常に低い値（数μs〜20μs程度）で安定していること**。
  - これが確認できれば、カーネルチューニングによってリアルタイムタスクが他のタスクの影響から完全に保護されていることの証明となります。
